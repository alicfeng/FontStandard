{"title":"Component Lifecycle Methods - Stencil","description":"Component Lifecycle Methods","url":"/docs/component-lifecycle","contributors":["jthoms1"],"headings":[{"id":"component-lifecycle-methods","level":1,"text":"Component Lifecycle Methods"},{"id":"connectedcallback","level":2,"text":"connectedCallback()"},{"id":"disconnectedcallback","level":2,"text":"disconnectedCallback()"},{"id":"componentwillload","level":2,"text":"componentWillLoad()"},{"id":"componentdidload","level":2,"text":"componentDidLoad()"},{"id":"componentshouldupdate","level":2,"text":"componentShouldUpdate()"},{"id":"componentwillrender","level":2,"text":"componentWillRender()"},{"id":"componentdidrender","level":2,"text":"componentDidRender()"},{"id":"componentwillupdate","level":2,"text":"componentWillUpdate()"},{"id":"componentdidupdate","level":2,"text":"componentDidUpdate()"},{"id":"rendering-state","level":2,"text":"Rendering State"},{"id":"lifecycle-hierarchy","level":2,"text":"Lifecycle Hierarchy"},{"id":"async-lifecycle-methods","level":2,"text":"Async Lifecycle Methods"},{"id":"example","level":2,"text":"Example"}],"srcPath":"./src/docs/components/component-lifecycle.md","hypertext":["div",null,["h1",{"id":"component-lifecycle-methods"},"\n  \n  Component Lifecycle Methods\n  \n"],"\n",["p",null,"Components have numerous lifecycle methods which can be used to know when the component \"will\" and \"did\" load, update, and render. These methods can be added to a component to hook into operations at the right time."],"\n",["p",null,"Implement one of the following methods within a component class and Stencil will automatically call them in the right order:"],"\n",["p",null,["lifecycle-chart",null]],"\n\n",["h2",{"id":"connectedcallback"},"\n  ",["a",{"class":"heading-link","href":"#connectedcallback"},["app-icon",{"name":"link"}],"\n  connectedCallback()\n  "],"\n"],"\n",["p",null,"Called every time the component is connected to the DOM.\nWhen the component is first connected, this method is called before ",["code",null,"componentWillLoad"],"."],"\n",["p",null,"It's important to note that this method can be called more than once, everytime, the element is ",["strong",null,"attached"]," or ",["strong",null,"moved"]," in the DOM."],"\n\n  ",["highlight-code",null,"\n    ",["pre",{"class":"language-tsx"},["code",{"class":"language-tsx"},["span",{"class":"token keyword"},"const"]," el ",["span",{"class":"token operator"},"="]," document",["span",{"class":"token punctuation"},"."],["span",{"class":"token function"},"createElement"],["span",{"class":"token punctuation"},"("],["span",{"class":"token string"},"'my-cmp'"],["span",{"class":"token punctuation"},")"],["span",{"class":"token punctuation"},";"],"\ndocument",["span",{"class":"token punctuation"},"."],"body",["span",{"class":"token punctuation"},"."],["span",{"class":"token function"},"appendChild"],["span",{"class":"token punctuation"},"("],"el",["span",{"class":"token punctuation"},")"],["span",{"class":"token punctuation"},";"],"\n",["span",{"class":"token comment"},"// connectedCallback() called"],"\n",["span",{"class":"token comment"},"// componentWillLoad() called (first time)"],"\n\nel",["span",{"class":"token punctuation"},"."],["span",{"class":"token function"},"remove"],["span",{"class":"token punctuation"},"("],["span",{"class":"token punctuation"},")"],["span",{"class":"token punctuation"},";"],"\n",["span",{"class":"token comment"},"// disconnectedCallback()"],"\n\ndocument",["span",{"class":"token punctuation"},"."],"body",["span",{"class":"token punctuation"},"."],["span",{"class":"token function"},"appendChild"],["span",{"class":"token punctuation"},"("],"el",["span",{"class":"token punctuation"},")"],["span",{"class":"token punctuation"},";"],"\n",["span",{"class":"token comment"},"// connectedCallback() called again, but `componentWillLoad` is not."]]],"\n  "],"\n  ",["p",null,"It's a good practice to use this hook"],"\n",["p",null,"This ",["code",null,"lifecycle"]," hook follows the same semantics as the one described by the ",["a",{"href":"https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements"},"Custom Elements Spec"]],"\n\n",["h2",{"id":"disconnectedcallback"},"\n  ",["a",{"class":"heading-link","href":"#disconnectedcallback"},["app-icon",{"name":"link"}],"\n  disconnectedCallback()\n  "],"\n"],"\n",["p",null,"Called every time the component is disconnected from the DOM, ie, it can be dispatched more than once, DO not confuse with a \"onDestroy\" kind of event."],"\n",["p",null,"This ",["code",null,"lifecycle"]," hook follows the same semantics as the one described by the ",["a",{"href":"https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements"},"Custom Elements Spec"],"."],"\n\n",["h2",{"id":"componentwillload"},"\n  ",["a",{"class":"heading-link","href":"#componentwillload"},["app-icon",{"name":"link"}],"\n  componentWillLoad()\n  "],"\n"],"\n",["p",null,"Called once just after the component is first connected to the DOM. Since this method is only called once, it's a good place to load data asynchronously."],"\n",["p",null,"A promise can be returned, that can be used to wait for the first render."],"\n\n",["h2",{"id":"componentdidload"},"\n  ",["a",{"class":"heading-link","href":"#componentdidload"},["app-icon",{"name":"link"}],"\n  componentDidLoad()\n  "],"\n"],"\n",["p",null,"Called once just after the component fully loaded and the first ",["code",null,"render()"]," occurs."],"\n\n",["h2",{"id":"componentshouldupdate"},"\n  ",["a",{"class":"heading-link","href":"#componentshouldupdate"},["app-icon",{"name":"link"}],"\n  componentShouldUpdate()\n  "],"\n"],"\n",["p",null,"This hook is called when a component's ",["code",null,"Prop"]," or ",["code",null,"State"]," property changes and a rerender is about to be requested. This hook receives three arguments: the new value, the old value and the name of the changed state. It should return a boolean to indicate if the component should rerender (",["code",null,"true"],") or not (",["code",null,"false"],")."],"\n",["p",null,"A couple of things to notice is that this method will not be executed before the initial render, that is, when the component is first attached to the dom, nor when a rerender is already scheduled in the next frame."],"\n",["p",null,"Letâ€™s say the following two props of a component change synchronously:"],"\n\n  ",["highlight-code",null,"\n    ",["pre",{"class":"language-tsx"},["code",{"class":"language-tsx"},"component",["span",{"class":"token punctuation"},"."],"somePropA ",["span",{"class":"token operator"},"="]," ",["span",{"class":"token number"},"42"],["span",{"class":"token punctuation"},";"],"\ncomponent",["span",{"class":"token punctuation"},"."],"somePropB ",["span",{"class":"token operator"},"="]," ",["span",{"class":"token number"},"88"],["span",{"class":"token punctuation"},";"]]],"\n  "],"\n  ",["p",null,"The ",["code",null,"componentShouldUpdate"]," will be first called with arguments: ",["code",null,"42"],", ",["code",null,"undefined"]," and ",["code",null,"somePropA"],". If it does return ",["code",null,"true"],", the hook will not be called again since the rerender is already scheduled to happen. Instead, if the first hook returned ",["code",null,"false"],", then ",["code",null,"componentShouldUpdate"]," will be called again with ",["code",null,"88"],", ",["code",null,"undefined"]," and ",["code",null,"somePropB"]," as arguments, triggered by the ",["code",null,"component.somePropB = 88"]," mutation."],"\n",["p",null,"Since the execution of this hook might be conditioned, it's not good to rely on it to watch for prop changes, instead use the ",["code",null,"@Watch"]," decorator for that."],"\n\n",["h2",{"id":"componentwillrender"},"\n  ",["a",{"class":"heading-link","href":"#componentwillrender"},["app-icon",{"name":"link"}],"\n  componentWillRender()\n  "],"\n"],"\n",["p",null,"Called before every ",["code",null,"render()"],"."],"\n",["p",null,"A promise can be returned, that can be used to wait for the upcoming render."],"\n\n",["h2",{"id":"componentdidrender"},"\n  ",["a",{"class":"heading-link","href":"#componentdidrender"},["app-icon",{"name":"link"}],"\n  componentDidRender()\n  "],"\n"],"\n",["p",null,"Called after every ",["code",null,"render()"],"."],"\n\n",["h2",{"id":"componentwillupdate"},"\n  ",["a",{"class":"heading-link","href":"#componentwillupdate"},["app-icon",{"name":"link"}],"\n  componentWillUpdate()\n  "],"\n"],"\n",["p",null,"Called when the component is about to be updated because some ",["code",null,"Prop()"]," or ",["code",null,"State()"]," changed.\nIt's never called during the first ",["code",null,"render()"],"."],"\n",["p",null,"A promise can be returned, that can be used to wait for the next render."],"\n\n",["h2",{"id":"componentdidupdate"},"\n  ",["a",{"class":"heading-link","href":"#componentdidupdate"},["app-icon",{"name":"link"}],"\n  componentDidUpdate()\n  "],"\n"],"\n",["p",null,"Called just after the component updates.\nIt's never called during the first ",["code",null,"render()"],"."],"\n\n",["h2",{"id":"rendering-state"},"\n  ",["a",{"class":"heading-link","href":"#rendering-state"},["app-icon",{"name":"link"}],"\n  Rendering State\n  "],"\n"],"\n",["p",null,"It's always recommended to make any rendered state updates within ",["code",null,"componentWillRender()"],", since this is the method which get called ",["em",null,"before"]," the ",["code",null,"render()"]," method. Alternatively, updating rendered state with the ",["code",null,"componentDidLoad()"],", ",["code",null,"componentDidUpdate()"]," and ",["code",null,"componentDidRender()"]," methods will cause another rerender, which isn't ideal for performance."],"\n",["p",null,"If state ",["em",null,"must"]," be updated in ",["code",null,"componentDidUpdate()"]," or ",["code",null,"componentDidRender()"],", it has the potential of getting components stuck in an infinite loop. If updating state within ",["code",null,"componentDidUpdate()"]," is unavoidable, then the method should also come with a way to detect if the props or state is \"dirty\" or not (is the data actually different or is it the same as before). By doing a dirty check, ",["code",null,"componentDidUpdate()"]," is able to avoid rendering the same data, and which in turn calls ",["code",null,"componentDidUpdate()"]," again."],"\n\n",["h2",{"id":"lifecycle-hierarchy"},"\n  ",["a",{"class":"heading-link","href":"#lifecycle-hierarchy"},["app-icon",{"name":"link"}],"\n  Lifecycle Hierarchy\n  "],"\n"],"\n",["p",null,"A useful feature of lifecycle methods is that they take their child component's lifecycle into consideration too. For example, if the parent component, ",["code",null,"cmp-a"],", has a child component, ",["code",null,"cmp-b"],", then ",["code",null,"cmp-a"]," isn't considered \"loaded\" until ",["code",null,"cmp-b"]," has finished loading. Another way to put it is that the deepest components finish loading first, then the ",["code",null,"componentDidLoad()"]," calls bubble up."],"\n",["p",null,"It's also important to note that even though Stencil can ",["a",{"href":"/blog/how-lazy-loading-web-components-work"},"lazy-load components"],", and has asynchronous rendering, the lifecycle methods are still called in the correct order. So while the top-level component could have already been loaded, all of its lifecycle methods are still called in the correct order, which means it'll wait for a child components to finish loading. The same goes for the exact opposite, where the child components may already be ready while the parent isn't."],"\n",["p",null,"In the example below we have a simple hierarchy of components. The numbered list shows the order of which the lifecycle methods will fire."],"\n\n  ",["highlight-code",null,"\n    ",["pre",{"class":"language-markup"},["code",{"class":"language-markup"},"  ",["span",{"class":"token tag"},["span",{"class":"token tag"},["span",{"class":"token punctuation"},"<"],"cmp-a"],["span",{"class":"token punctuation"},">"]],"\n    ",["span",{"class":"token tag"},["span",{"class":"token tag"},["span",{"class":"token punctuation"},"<"],"cmp-b"],["span",{"class":"token punctuation"},">"]],"\n      ",["span",{"class":"token tag"},["span",{"class":"token tag"},["span",{"class":"token punctuation"},"<"],"cmp-c"],["span",{"class":"token punctuation"},">"]],["span",{"class":"token tag"},["span",{"class":"token tag"},["span",{"class":"token punctuation"},"</"],"cmp-c"],["span",{"class":"token punctuation"},">"]],"\n    ",["span",{"class":"token tag"},["span",{"class":"token tag"},["span",{"class":"token punctuation"},"</"],"cmp-b"],["span",{"class":"token punctuation"},">"]],"\n  ",["span",{"class":"token tag"},["span",{"class":"token tag"},["span",{"class":"token punctuation"},"</"],"cmp-a"],["span",{"class":"token punctuation"},">"]]]],"\n  "],"\n  ",["ol",null,"\n",["li",null,["code",null,"cmp-a"]," - ",["code",null,"componentWillLoad()"]],"\n",["li",null,["code",null,"cmp-b"]," - ",["code",null,"componentWillLoad()"]],"\n",["li",null,["code",null,"cmp-c"]," - ",["code",null,"componentWillLoad()"]],"\n",["li",null,["code",null,"cmp-c"]," - ",["code",null,"componentDidLoad()"]],"\n",["li",null,["code",null,"cmp-b"]," - ",["code",null,"componentDidLoad()"]],"\n",["li",null,["code",null,"cmp-a"]," - ",["code",null,"componentDidLoad()"]],"\n"],"\n",["p",null,"Even if some components may or may not be already loaded, the entire component hierarchy waits on its child components to finish loading and rendering."],"\n\n",["h2",{"id":"async-lifecycle-methods"},"\n  ",["a",{"class":"heading-link","href":"#async-lifecycle-methods"},["app-icon",{"name":"link"}],"\n  Async Lifecycle Methods\n  "],"\n"],"\n",["p",null,"Lifecycle methods can also return promises which allows the method to asynchronously retrieve data or perform any async tasks. A great example of this is fetching data to be rendered in a component. For example, this very site you're reading first fetches content data before rendering. But because ",["code",null,"fetch()"]," is async, it's important that ",["code",null,"componentWillLoad()"]," returns a ",["code",null,"Promise"]," to ensure its parent component isn't considered \"loaded\" until all of its content has rendered."],"\n",["p",null,"Below is a quick example showing how ",["code",null,"componentWillLoad()"]," is able to have its parent component wait on it to finish loading its data."],"\n\n  ",["highlight-code",null,"\n    ",["pre",{"class":"language-tsx"},["code",{"class":"language-tsx"},["span",{"class":"token function"},"componentWillLoad"],["span",{"class":"token punctuation"},"("],["span",{"class":"token punctuation"},")"]," ",["span",{"class":"token punctuation"},"{"],"\n  ",["span",{"class":"token keyword"},"return"]," ",["span",{"class":"token function"},"fetch"],["span",{"class":"token punctuation"},"("],["span",{"class":"token string"},"'/some-data.json'"],["span",{"class":"token punctuation"},")"],"\n    ",["span",{"class":"token punctuation"},"."],["span",{"class":"token function"},"then"],["span",{"class":"token punctuation"},"("],["span",{"class":"token parameter"},"response"]," ",["span",{"class":"token operator"},"=>"]," response",["span",{"class":"token punctuation"},"."],["span",{"class":"token function"},"json"],["span",{"class":"token punctuation"},"("],["span",{"class":"token punctuation"},")"],["span",{"class":"token punctuation"},")"],"\n    ",["span",{"class":"token punctuation"},"."],["span",{"class":"token function"},"then"],["span",{"class":"token punctuation"},"("],["span",{"class":"token parameter"},"data"]," ",["span",{"class":"token operator"},"=>"]," ",["span",{"class":"token punctuation"},"{"],"\n      ",["span",{"class":"token keyword"},"this"],["span",{"class":"token punctuation"},"."],"content ",["span",{"class":"token operator"},"="]," data",["span",{"class":"token punctuation"},";"],"\n    ",["span",{"class":"token punctuation"},"}"],["span",{"class":"token punctuation"},")"],["span",{"class":"token punctuation"},";"],"\n",["span",{"class":"token punctuation"},"}"]]],"\n  "],"\n  \n",["h2",{"id":"example"},"\n  ",["a",{"class":"heading-link","href":"#example"},["app-icon",{"name":"link"}],"\n  Example\n  "],"\n"],"\n",["p",null,"This simple example shows a clock and updates the current time every second. The timer is started when the component is added to the DOM. Once it's removed from the DOM, the timer is stopped."],"\n\n  ",["highlight-code",null,"\n    ",["pre",{"class":"language-tsx"},["code",{"class":"language-tsx"},["span",{"class":"token keyword"},"import"]," ",["span",{"class":"token punctuation"},"{"]," Component",["span",{"class":"token punctuation"},","]," State",["span",{"class":"token punctuation"},","]," h ",["span",{"class":"token punctuation"},"}"]," ",["span",{"class":"token keyword"},"from"]," ",["span",{"class":"token string"},"'@stencil/core'"],["span",{"class":"token punctuation"},";"],"\n\n@",["span",{"class":"token function"},"Component"],["span",{"class":"token punctuation"},"("],["span",{"class":"token punctuation"},"{"],"\n  tag",["span",{"class":"token operator"},":"]," ",["span",{"class":"token string"},"'custom-clock'"],"\n",["span",{"class":"token punctuation"},"}"],["span",{"class":"token punctuation"},")"],"\n",["span",{"class":"token keyword"},"export"]," ",["span",{"class":"token keyword"},"class"]," ",["span",{"class":"token class-name"},"CustomClock"]," ",["span",{"class":"token punctuation"},"{"],"\n\n  timer",["span",{"class":"token operator"},":"]," ",["span",{"class":"token builtin"},"number"],["span",{"class":"token punctuation"},";"],"\n\n  @",["span",{"class":"token function"},"State"],["span",{"class":"token punctuation"},"("],["span",{"class":"token punctuation"},")"]," time",["span",{"class":"token operator"},":"]," ",["span",{"class":"token builtin"},"number"]," ",["span",{"class":"token operator"},"="]," Date",["span",{"class":"token punctuation"},"."],["span",{"class":"token function"},"now"],["span",{"class":"token punctuation"},"("],["span",{"class":"token punctuation"},")"],["span",{"class":"token punctuation"},";"],"\n\n  ",["span",{"class":"token function"},"connectedCallback"],["span",{"class":"token punctuation"},"("],["span",{"class":"token punctuation"},")"]," ",["span",{"class":"token punctuation"},"{"],"\n    ",["span",{"class":"token keyword"},"this"],["span",{"class":"token punctuation"},"."],"timer ",["span",{"class":"token operator"},"="]," window",["span",{"class":"token punctuation"},"."],["span",{"class":"token function"},"setInterval"],["span",{"class":"token punctuation"},"("],["span",{"class":"token punctuation"},"("],["span",{"class":"token punctuation"},")"]," ",["span",{"class":"token operator"},"=>"]," ",["span",{"class":"token punctuation"},"{"],"\n      ",["span",{"class":"token keyword"},"this"],["span",{"class":"token punctuation"},"."],"time ",["span",{"class":"token operator"},"="]," Date",["span",{"class":"token punctuation"},"."],["span",{"class":"token function"},"now"],["span",{"class":"token punctuation"},"("],["span",{"class":"token punctuation"},")"],["span",{"class":"token punctuation"},";"],"\n    ",["span",{"class":"token punctuation"},"}"],["span",{"class":"token punctuation"},","]," ",["span",{"class":"token number"},"1000"],["span",{"class":"token punctuation"},")"],["span",{"class":"token punctuation"},";"],"\n  ",["span",{"class":"token punctuation"},"}"],"\n\n  ",["span",{"class":"token function"},"disconnectedCallback"],["span",{"class":"token punctuation"},"("],["span",{"class":"token punctuation"},")"]," ",["span",{"class":"token punctuation"},"{"],"\n    window",["span",{"class":"token punctuation"},"."],["span",{"class":"token function"},"clearInterval"],["span",{"class":"token punctuation"},"("],["span",{"class":"token keyword"},"this"],["span",{"class":"token punctuation"},"."],"timer",["span",{"class":"token punctuation"},")"],["span",{"class":"token punctuation"},";"],"\n  ",["span",{"class":"token punctuation"},"}"],"\n\n  ",["span",{"class":"token function"},"render"],["span",{"class":"token punctuation"},"("],["span",{"class":"token punctuation"},")"]," ",["span",{"class":"token punctuation"},"{"],"\n    ",["span",{"class":"token keyword"},"const"]," time ",["span",{"class":"token operator"},"="]," ",["span",{"class":"token keyword"},"new"]," ",["span",{"class":"token class-name"},"Date"],["span",{"class":"token punctuation"},"("],["span",{"class":"token keyword"},"this"],["span",{"class":"token punctuation"},"."],"time",["span",{"class":"token punctuation"},")"],["span",{"class":"token punctuation"},"."],["span",{"class":"token function"},"toLocaleTimeString"],["span",{"class":"token punctuation"},"("],["span",{"class":"token punctuation"},")"],["span",{"class":"token punctuation"},";"],"\n\n    ",["span",{"class":"token keyword"},"return"]," ",["span",{"class":"token punctuation"},"("],"\n      ",["span",{"class":"token tag"},["span",{"class":"token tag"},["span",{"class":"token punctuation"},"<"],"span"],["span",{"class":"token punctuation"},">"]],["span",{"class":"token punctuation"},"{"]," time ",["span",{"class":"token punctuation"},"}"],["span",{"class":"token tag"},["span",{"class":"token tag"},["span",{"class":"token punctuation"},"</"],"span"],["span",{"class":"token punctuation"},">"]],"\n    ",["span",{"class":"token punctuation"},")"],["span",{"class":"token punctuation"},";"],"\n  ",["span",{"class":"token punctuation"},"}"],"\n",["span",{"class":"token punctuation"},"}"]]],"\n  "],"\n  ",["blockquote",null,"\n",["p",null,"Here is the example running.  If you want to see it in action then just inspect it with dev tools.\n",["custom-clock",null]],"\n"]]}